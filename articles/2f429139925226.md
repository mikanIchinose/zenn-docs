---
title: "å…¥é–€ Jetpack Compose Animation part1"
emoji: "ğŸ•"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: ["android","jetpackcompose"]
published: true
---

## ã¯ã˜ã‚ã«
Animationã«ã¤ã„ã¦è©³ã—ããªã‚‹ãŸã‚ã«ã€å…¬å¼ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’èª­ã‚“ã§å†™çµŒã—ãŸå†…å®¹ã‚’ã¾ã¨ã‚ã¦ã„ãã¾ã™

## [AnimatedVisibility](https://developer.android.com/reference/kotlin/androidx/compose/animation/package-summary#(androidx.compose.animation.core.Transition).AnimatedVisibility(kotlin.Function1,androidx.compose.ui.Modifier,androidx.compose.animation.EnterTransition,androidx.compose.animation.ExitTransition,kotlin.Function1))

è¦ç´ ã®è¡¨ç¤ºãƒ»éè¡¨ç¤ºã«ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ã¤ã‘ã‚‹ãŸã‚ã®Composableé–¢æ•°

### ã‚·ãƒ³ãƒ—ãƒ«ãªä½¿ã„æ–¹

```kotlin
@Composable
fun SimpleAnimatedVisibility(modifier: Modifier = Modifier) {
    var visible by remember { mutableStateOf(true) }
    Column(modifier) {
        Button({ visible = !visible }) {
            Text(if (visible) "Hide" else "Show")
        }
        AnimatedVisibility(
            visible = visible,
        ) {
            Box(
                Modifier
                    .fillMaxWidth()
                    .height(100.dp)
                    .background(MaterialTheme.colorScheme.primaryContainer)
            )
        }
    }
}
```

![](/images/2f429139925226/SimpleAnimatedVisibility.gif =200x)

### [Modifier.animateEnterExit](https://developer.android.com/reference/kotlin/androidx/compose/animation/AnimatedVisibilityScope#(androidx.compose.ui.Modifier).animateEnterExit(androidx.compose.animation.EnterTransition,androidx.compose.animation.ExitTransition,kotlin.String))

AnimatedVisibilityã®ä¸­ã§ã¯ `Modifier.animateEnterExit()` ãŒåˆ©ç”¨ã§ãã€ã“ã‚Œã«ã‚ˆã£ã¦å­è¦ç´ ã®Enter/Exitã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã™ã‚‹ã“ã¨ãŒã§ãã¾ã™

```kotlin
/**
 * Enter animation
 *   è¦ªãŒå…ˆã«è¡¨ç¤ºã•ã‚Œã¦ã€é…ã‚Œã¦å­ãŒfadeInã™ã‚‹
 * Exit animation
 *   å­ãŒå…ˆã«fadeOutã—ã¦ã€ãã®å¾Œã€è¦ªã‚‚éè¡¨ç¤ºã«ãªã‚‹
 */
@Composable
fun AnimatedVisibilityWithAnimateEnterExit(modifier: Modifier = Modifier) {
    var visible by remember { mutableStateOf(true) }
    Column(modifier) {
        Button({ visible = !visible }) {
            Text(if (visible) "Hide" else "Show")
        }
        AnimatedVisibility(
            visible = visible,
            exit = fadeOut(
                animationSpec = tween(delayMillis = 300)
            ) + shrinkVertically(
                animationSpec = tween(delayMillis = 300)
            ),
        ) {
            Box(
                Modifier
                    .fillMaxWidth()
                    .height(200.dp)
                    .background(Color(0x88000000))
                    .padding(16.dp)
            ) {
                Box(
                    Modifier
                        .animateEnterExit(
                            enter = fadeIn(
                                animationSpec = tween(delayMillis = 300)
                            )
                        )
                        .clip(RoundedCornerShape(10.dp))
                        .requiredHeight(100.dp)
                        .fillMaxWidth()
                        .background(Color.White)
                ) {
                    Text("Hello World")
                }
            }
        }
    }
}
```

![](/images/2f429139925226/AnimatedVisibilityWithAnimateEnterExit.gif =200x)

### [MutableTransitionState](https://developer.android.com/reference/kotlin/androidx/compose/animation/core/MutableTransitionState)

AnimatedVisibilityã¯MutableTransitionStateã‚’å—ã‘å–ã‚‹ã“ã¨ã‚‚ã§ãã€ã“ã‚Œã‚’ä½¿ã†ã“ã¨ã§ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³çŠ¶æ…‹ã®åˆ¶å¾¡ãŒã§ãã‚‹ã»ã‹ã€AnimatedVisibilityãŒCompositionã«è¿½åŠ ã•ã‚ŒãŸã®ã¡ç›´ã¡ã«ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’é–‹å§‹ã™ã‚‹ã®ã«ã‚‚åˆ©ç”¨ã§ãã¾ã™

```kotlin
@Composable
fun AnimatedVisibilityWithMutableTransitionState(modifier: Modifier = Modifier) {
    val state = remember {
        MutableTransitionState(false).apply {
            // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ç›´ã¡ã«é–‹å§‹ã™ã‚‹
            targetState = true
        }
    }

    Column(modifier) {
        Button({ state.targetState = !state.targetState }) {
            Text(if (state.currentState) "Hide" else "Show")
        }
        Text(
            text = when {
                state.isIdle && state.currentState -> "Visible"
                !state.isIdle && state.currentState -> "Disappearing"
                state.isIdle && !state.currentState -> "Invisible"
                else -> "Appearing"
            }
        )
        AnimatedVisibility(
            visibleState = state,
            enter = fadeIn(
                animationSpec = tween(delayMillis = 300)
            ) + expandHorizontally(
                animationSpec = tween(delayMillis = 300)
            ),
            exit = shrinkHorizontally(
                animationSpec = tween(delayMillis = 300)
            ) + fadeOut(
                animationSpec = tween(delayMillis = 300)
            )
        ) {
            Text(text = "Hello, world!")
        }
    }
}
```

![](/images/2f429139925226/AnimatedVisibilityWithMutableTransitionState.gif =200x)

## [AnimatedContnet](https://developer.android.com/reference/kotlin/androidx/compose/animation/package-summary#AnimatedContent(kotlin.Any,androidx.compose.ui.Modifier,kotlin.Function1,androidx.compose.ui.Alignment,kotlin.String,kotlin.Function1,kotlin.Function2))

çŠ¶æ…‹ã®å¤‰æ›´ã‚’èµ·ç‚¹ã«ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ç™ºç”Ÿã•ã›ã‚‹Composable

### ã‚·ãƒ³ãƒ—ãƒ«ãªä½¿ã„æ–¹

```kotlin
@Composable
fun SimpleAnimatedContent(modifier: Modifier = Modifier) {
    Row(modifier) {
        // targetState
        var count by remember { mutableIntStateOf(0) }
        Button(onClick = { count++ }) {
            Text("Add")
        }
        AnimatedContent(
            targetState = count,
            label = "animated content"
        ) { targetCount ->
            // lambdaãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’ä½¿ã†å¿…è¦ãŒã‚ã‚‹
            Text(text = "Count: $targetCount")
        }
    }
}
```

![](/images/2f429139925226/SimpleAnimatedContent.gif)

### ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã®ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚º

AnimatedVisibilityã§ã¯enter, exitãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’ç”¨ã„ã¦ã€ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã§ãã¾ã—ãŸãŒã€AnimatedContentã®å ´åˆã¯ã€transitionSpecãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’ç”¨ã„ã§ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã—ã¾ã™

```kotlin
transitionSpec: AnimatedContentTransitionScope<S>.() -> ContentTransform = {
    (fadeIn(animationSpec = tween(220, delayMillis = 90)) +
        scaleIn(initialScale = 0.92f, animationSpec = tween(220, delayMillis = 90)))
        .togetherWith(fadeOut(animationSpec = tween(90)))
},
```

AnimatedVisibilityã¨åŒã˜è¦é ˜ã§EnterTransitionã¨ExitTransitionã‚’ä½œæˆã—ã€ä¸¡è€…ã‚’ `togetherWith` ã§åˆæˆã—ã¦ã€ContentTransitionã«ã—ã¾ã™

ã•ã‚‰ã«SizeTransformã‚’ä½¿ã†ã“ã¨ã§ã€ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã®ã‚µã‚¤ã‚ºã«ã¤ã„ã¦ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚‚åˆ¶å¾¡ã§ãã¾ã™

```kotlin
Column {
    var count by remember { mutableIntStateOf(0) }
                                                                                           
    Row {
        Button(onClick = { count++ }) {
            Text("Add")
        }
        Button(onClick = { count-- }) {
            Text("Subtract")
        }
    }
    Row(
        verticalAlignment = Alignment.CenterVertically
    ) {
        Text("clip = true")
        AnimatedContent(
            targetState = count,
            transitionSpec = {
                val contentTransform = if (targetState > initialState) {
                    val enter = slideInVertically(tween(500)) { it } + fadeIn(tween(500))
                    val exit = slideOutVertically(tween(500)) { -it } + fadeOut(tween(500))
                    enter togetherWith exit
                } else {
                    // ãƒ‡ã‚¯ãƒªãƒ¡ãƒ³ãƒˆã®éš›ã¯ã€ä¸Šã‹ã‚‰ä¸‹ã«ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
                    val enter = slideInVertically(tween(500)) { -it } + fadeIn(tween(500))
                    val exit = slideOutVertically(tween(500)) { it } + fadeOut(tween(500))
                    enter togetherWith exit
                }
                // clip = false ã«ã™ã‚‹ã“ã¨ã§ã€ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã®é ˜åŸŸã‚’ã¯ã¿å‡ºã—ã¦ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã™ã‚‹
                // ãã®ã¾ã¾ã®çŠ¶æ…‹ã ã¨ã€ã‚¯ãƒªãƒƒãƒ”ãƒ³ã‚°ã•ã‚Œã‚‹ã®ã§ã‚³ãƒ³ãƒ†ãƒ³ãƒ„é ˜åŸŸå¤–ã«ãªã‚‹ã¨è¦‹ãˆãªããªã‚‹
                contentTransform
            },
            label = "animated content",
            modifier = Modifier
                .padding(8.dp)
                .border(1.dp, Color.Black),
        ) { targetCount ->
            Text(
                text = "$targetCount",
            )
        }
                                                                                           
        Text("clip = false")
        AnimatedContent(
            targetState = count,
            transitionSpec = {
                val contentTransform = if (targetState > initialState) {
                    val enter = slideInVertically(tween(500)) { it } + fadeIn(tween(500))
                    val exit = slideOutVertically(tween(500)) { -it } + fadeOut(tween(500))
                    enter togetherWith exit
                } else {
                    val enter = slideInVertically(tween(500)) { -it } + fadeIn(tween(500))
                    val exit = slideOutVertically(tween(500)) { it } + fadeOut(tween(500))
                    enter togetherWith exit
                }
                // clip = false ã«ã™ã‚‹ã“ã¨ã§ã€ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã®é ˜åŸŸã‚’ã¯ã¿å‡ºã—ã¦ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã™ã‚‹
                // ãã®ã¾ã¾ã®çŠ¶æ…‹ã ã¨ã€ã‚¯ãƒªãƒƒãƒ”ãƒ³ã‚°ã•ã‚Œã‚‹ã®ã§ã‚³ãƒ³ãƒ†ãƒ³ãƒ„é ˜åŸŸå¤–ã«ãªã‚‹ã¨è¦‹ãˆãªããªã‚‹
                val sizeTransform = SizeTransform(false)
                contentTransform using sizeTransform
            },
            label = "animated content",
            modifier = Modifier
                .padding(8.dp)
                .border(1.dp, Color.Black),
        ) { targetCount ->
            Text(
                text = "$targetCount",
            )
        }
    }
}
```

![](/images/2f429139925226/AnimatedContentWithCustomTransition.gif =200x)

ä½™è«‡
EnterTransitionã¨ExitTransitionã‚’åˆæˆã™ã‚‹é–¢æ•°åã¯ã‹ã¤ã¦ã¯withã§ã—ãŸãŒã€ç¾åœ¨ã§ã¯togetherWithã«ãªã£ã¦ã„ã‚‹ã‚ˆã†ã§ã—ãŸã€‚å¤‰æ›´ã«ãªã£ãŸç†ç”±ã¯å®šã‹ã§ã¯ãªã„ã§ã™ãŒã€Kotlinã«withé–¢æ•°ãŒå…ƒã€…ã‚ã‚‹ã®ã§ãã‚Œã¨æ··åŒã—ãªã„ã‚ˆã†ã«ã™ã‚‹ãŸã‚ã«å¤‰æ›´ã«ãªã£ãŸã‚“ã§ã™ã‹ã­
https://android-review.googlesource.com/c/platform/frameworks/support/+/2514375

### SizeTransformã‚’ä½¿ã£ãŸã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³

SizeTransformã‚’ç”¨ã„ã‚‹ã“ã¨ã§ã‚µã‚¤ã‚ºã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³åˆ¶å¾¡ã‚’ç´°ã‹ãè¡Œãˆã¾ã™
ä¸‹ã®ä¾‹ã§ã¯ã€ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã®ä¼¸ç¸®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã—ã¦ã„ã¾ã™
åºƒã’ã‚‹éš›ã¯ã¾ãšæ¨ªæ–¹å‘ã«åºƒã’ãŸã®ã¡ã€ç¸¦æ–¹å‘ã«åºƒã’ã€ç•³ã‚€éš›ã¯é€†ã«ã—ã¦ã„ã¾ã™

```kotlin
var expanded by remember { mutableStateOf(false) }
Surface(
    color = MaterialTheme.colorScheme.primary,
    onClick = { expanded = !expanded },
) {
    AnimatedContent(
        contentAlignment = Alignment.TopStart,
        targetState = expanded,
        transitionSpec = {
            fadeIn() togetherWith
                    fadeOut() using
                    SizeTransform(false) { initialSize, targetSize ->
                        if (targetState) {
                            // expand
                            keyframes {
                                // ã¾ãšæ¨ªã«ä¼¸ã°ã™
                                IntSize(targetSize.width, initialSize.height) at 150
                                durationMillis = 300
                                // ãã®å¾Œç¸¦ã«ä¼¸ã°ã™
                            }
                        } else {
                            // shrink
                            keyframes {
                                // ã¾ãšç¸¦ã«ç¸®ã‚ã‚‹
                                IntSize(initialSize.width, targetSize.height) at 150
                                durationMillis = 300
                                // ãã®å¾Œæ¨ªã«ç¸®ã‚ã‚‹
                            }
                        }
                    }
        },
        label = "size transform",
        modifier = Modifier.padding(16.dp)
    ) { targetExpanded ->
        if (targetExpanded) {
            Text(
                """
                EnterTransition defines how the target content should appear, and ExitTransition defines how the initial content should disappear. In addition to all of the EnterTransition and ExitTransition functions available for AnimatedVisibility, AnimatedContent offers slideIntoContainer and slideOutOfContainer. These are convenient alternatives to slideInHorizontally/Vertically and slideOutHorizontally/Vertically that calculate the slide distance based on the sizes of the initial content and the target content of the AnimatedContent content.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         
                SizeTransform defines how the size should animate between the initial and the target contents. You have access to both the initial size and the target size when you are creating the animation. SizeTransform also controls whether the content should be clipped to the component size during animations.
            """.trimIndent()
            )
        } else {
            Icon(Icons.Default.Edit, null)
        }
    }
}
```

![](/images/2f429139925226/AnimatedContentSizeTransform.gif)

## [Crossfade](https://developer.android.com/reference/kotlin/androidx/compose/animation/package-summary#(androidx.compose.animation.core.Transition).Crossfade(androidx.compose.ui.Modifier,androidx.compose.animation.core.FiniteAnimationSpec,kotlin.Function1,kotlin.Function1))

ç•°ãªã‚‹2ã¤ã®ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆå¤‰æ›´ã«ã‚¯ãƒ­ã‚¹ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’è¿½åŠ ã™ã‚‹Composable

```kotlin
@Composable
fun CrossfadeSample(modifier: Modifier = Modifier) {
    var currentPage by remember { mutableStateOf("A") }
    Column(modifier) {
        Button({
            currentPage = when (currentPage) {
                "A" -> "B"
                else -> "A"
            }
        }) {
            Text("Change")
        }
        Crossfade(targetState = currentPage, label = "cross fade") { screen ->
            when (screen) {
                "A" -> Text("Page A")
                "B" -> Text("Page B")
            }
        }
    }
}
```

![](/images/2f429139925226/CrossfadeSample.gif)

## [Modifier.animateContentSize](https://developer.android.com/reference/kotlin/androidx/compose/animation/package-summary#(androidx.compose.ui.Modifier).animateContentSize(androidx.compose.animation.core.FiniteAnimationSpec,kotlin.Function2))

ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã®ã‚µã‚¤ã‚ºå¤‰æ›´ã«ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ã¤ã‘ã¦ãã‚Œã‚‹Modifier

æ³¨æ„: ã‚µã‚¤ã‚ºå¤‰æ›´ã‚’æ­£ç¢ºã«ä¼æ¬ã•ã›ã‚‹ãŸã‚ã«ã€ã‚µã‚¤ã‚ºç³»ã®Modifier(sizeã‚„defaultMinSizeãªã©)ã‚ˆã‚Šã‚‚å…ˆã«å‘¼ã³å‡ºã™

```kotlin
@Composable
fun AnimateContentSizeSample(modifier: Modifier = Modifier) {
    var expanded by remember { mutableStateOf(false) }
    Box(
        modifier = modifier
            .background(MaterialTheme.colorScheme.primary)
            .animateContentSize()
            .height(if (expanded) 400.dp else 200.dp)
            .fillMaxWidth()
            .clickable {
                expanded = !expanded
            }
    )
}
```

![](/images/2f429139925226/AnimateContentSizeSample.gif)

## å‚è€ƒæ–‡çŒ®

https://developer.android.com/develop/ui/compose/animation/composables-modifiers?hl=en
https://github.com/mikanIchinose/android-compose-animation-sample