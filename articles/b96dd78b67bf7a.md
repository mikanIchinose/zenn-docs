---
title: "å…¥é–€ Jetpack Compose Animation part2"
emoji: "â›³"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: ["android", "jetpackcompose"]
published: true
---

## ã¯ã˜ã‚ã«
https://zenn.dev/solenoid/articles/2f429139925226
å‰å›ã¯ã€[Animation modifiers and composables](https://developer.android.com/develop/ui/compose/animation/composables-modifiers)ã‚’èª­ã‚“ã§å­¦ç¿’ã—ãŸå†…å®¹ã‚’ã¾ã¨ã‚ã¾ã—ãŸã€‚
ä»Šå›ã¯ã€[Value-based animations](https://developer.android.com/develop/ui/compose/animation/value-based)ã‚’èª­ã‚“ã§å­¦ç¿’ã—ãŸå†…å®¹ã‚’ã¾ã¨ã‚ã¾ã™ã€‚

## animate*AsState
å˜ä¸€ã®å€¤ã‚’ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³åŒ–ã™ã‚‹ãŸã‚ã®APIã§ã™ã€‚

ç¨®é¡ã¯ä»¥ä¸‹ã®é€šã‚Šã§ã™ã€‚
- androidx.compose.animation
    - animateColorAsState
- androidx.compose.animation.core
    - animateDpAsState
    - animateFloatAsState
    - animateIntAsState
    - animateIntOffsetAsState
    - animateIntSizeAsState
    - animateOffsetAsState
    - animateRectAsState
    - animateSizeAsState
    - animateValueAsState

animate*AsStateã¯ã€ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã®çµ‚ç‚¹ã®ã¿ã‚’æŒ‡å®šã—ã€ãã®å€¤ãŒå¤‰åŒ–ã—ãŸã¨ãã«ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’é–‹å§‹ã—ã¾ã™ã€‚

```kotlin
@Composable
fun AnimateSomethingAsStateSample(modifier: Modifier = Modifier) {
    var enabled by remember { mutableStateOf(true) }
    val animatedAlpha by animateFloatAsState(if (enabled) 1f else 0.5f, label = "alpha")
    val width by animateDpAsState(if (enabled) 200.dp else 100.dp, label = "width")
    val background by animateColorAsState(
        if (enabled) {
            MaterialTheme.colorScheme.primary
        } else {
            MaterialTheme.colorScheme.primaryContainer
        },
        label = "color"
    )
    val textColor by animateColorAsState(
        if (enabled) {
            MaterialTheme.colorScheme.onPrimary
        } else {
            MaterialTheme.colorScheme.onPrimaryContainer
        },
        label = "color"
    )
    val offset by animateIntOffsetAsState(
        if (enabled) {
            IntOffset(100, 100)
        } else {
            IntOffset(0, 0)
        },
        label = "offset"
    )
    Box(
        modifier = modifier
            .height(100.dp)
            .width(width)
            .graphicsLayer {
                alpha = animatedAlpha
            }
            .background(background)
            .clickable {
                enabled = !enabled
            }
    ) {
        Text(
            text = "Hello World",
            color = textColor,
            modifier = Modifier.offset { offset }
        )
    }
}
```

![AnimateSomethingAsStateSample.gif](/images/b96dd78b67bf7a/AnimateSomethingAsStateSample.gif)

## Transition

1ã¤ã®ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã«å¯¾ã—ã¦è¤‡æ•°ã®å€¤ã‚’ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³åŒ–ã™ã‚‹ãŸã‚ã®APIã§ã™ã€‚
animate*AsStateã¯ã€1ã¤ã®ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã«å¯¾ã—ã¦1ã¤ã®å€¤ã‚’ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³åŒ–ã™ã‚‹ã®ã«å¯¾ã—ã€Transitionã¯ã€1ã¤ã®ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã«å¯¾ã—ã¦è¤‡æ•°ã®å€¤ã‚’ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³åŒ–ã§ãã¾ã™ã€‚

```kotlin
enum class BoxState {
    Collapsed,
    Expanded,
}

@Composable
fun TransitionSample(modifier: Modifier = Modifier) {
    var currentState by remember { mutableStateOf(BoxState.Collapsed) }
    val transition = updateTransition(currentState, label = "box state")
    val size by transition.animateSize { state ->
        when (state) {
            BoxState.Collapsed -> Size(100f, 100f)
            BoxState.Expanded -> Size(200f, 200f)
        }
    }
    val borderWidth by transition.animateDp { state ->
        when (state) {
            BoxState.Collapsed -> 1.dp
            BoxState.Expanded -> 2.dp
        }
    }
    val color by transition.animateColor(
        transitionSpec = {
            when {
                BoxState.Expanded isTransitioningTo BoxState.Collapsed ->
                    spring(stiffness = 50f)

                else ->
                    tween(durationMillis = 500)
            }
        },
        label = "color",
    ) { state ->
        when (state) {
            BoxState.Collapsed -> MaterialTheme.colorScheme.primary
            BoxState.Expanded -> MaterialTheme.colorScheme.background
        }
    }
    Box(
        modifier = modifier
            .size(size.width.dp, size.height.dp)
            .border(borderWidth, Color.Black)
            .background(color)
            .clickable {
                currentState = when (currentState) {
                    BoxState.Collapsed -> BoxState.Expanded
                    BoxState.Expanded -> BoxState.Collapsed
                }
            }
    )
}
```

![TransitionSample.gif](/images/b96dd78b67bf7a/TransitionSample.gif)

### Transition.createChildTransition

TransitionãŒè¤‡é›‘ã«çµ¡ã¿åˆã£ã¦ã„ã‚‹å ´åˆã€Transition.createChildTransitionã‚’ä½¿ç”¨ã—ã¦ã€è¦ªã®Transitionã‹ã‚‰å­ã®Transitionã‚’ä½œæˆã™ã‚‹ã“ã¨ã§æ•´ç†ã§ãã¾ã™ã€‚
(ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã«æ›¸ã„ã¦ã‚ã‚‹ã“ã¨ã‚’ã¾ã‚“ã¾æ›¸ã„ã¦ã„ã‚‹ã ã‘ã§ã€ä¸‹ã®ä¾‹ã¯æœ‰ç”¨ãªä¾‹ã§ã¯ãªã„ã§ã™ã€‚ğŸ™)

```kotlin
enum class DialerState { DialerMinimized, NumberPad }

@Composable
fun DialerButton(
    isVisibleTransition: Transition<Boolean>,
    onClick: () -> Unit,
) {
    isVisibleTransition.AnimatedVisibility(
        visible = { it },
        enter = fadeIn(),
        exit = fadeOut(),
    ) {
        Button(
            onClick = onClick,
            modifier = Modifier.width(200.dp)
        ) {
            Text("Dialer")
        }
    }
}

@Composable
fun NumberPad(
    isVisibleTransition: Transition<Boolean>,
    onClick: () -> Unit,
) {
    isVisibleTransition.AnimatedVisibility(
        visible = { it },
        enter = fadeIn(),
        exit = fadeOut(),
    ) {
        Button(
            onClick = onClick,
            colors = ButtonDefaults.buttonColors().copy(
                containerColor = MaterialTheme.colorScheme.secondary,
                contentColor = MaterialTheme.colorScheme.onSecondary,
            ),
            modifier = Modifier.width(200.dp)
        ) {
            Text("NumberPad")
        }
    }
}

@OptIn(ExperimentalTransitionApi::class)
@Composable
fun Dialer(
    modifier: Modifier = Modifier,
) {
    var dialerState by remember { mutableStateOf(DialerState.DialerMinimized) }
    val transition = updateTransition(dialerState, label = "dialer state")
    Box(modifier) {
        NumberPad(
            transition.createChildTransition {
                it == DialerState.NumberPad
            },
            onClick = { dialerState = DialerState.DialerMinimized }
        )
        DialerButton(
            transition.createChildTransition {
                it == DialerState.DialerMinimized
            },
            onClick = { dialerState = DialerState.NumberPad }
        )
    }
}
```

![Dialer.gif](/images/b96dd78b67bf7a/Dialer.gif)

### Transition.AnimatedVisibility, Transition.AnimatedContent

Transitionã‚’ãƒˆãƒªã‚¬ãƒ¼ã¨ã—ã¦ã€AnimatedVisibilityã€AnimatedContentãŒå®Ÿè¡Œã§ãã‚‹ã€‚
é€šå¸¸ã®AnimatedVisibilityã¯Booleanã‚’ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã¨ã—ã¦ã„ã‚‹ãŒã€Transition.AnimatedVisibilityã¯ã€ãƒ©ãƒ ãƒ€å¼ã‚’å—ã‘å–ã£ã¦Transitionã®ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‹ã‚‰Booleanã‚’ç®—å‡ºã—ãã‚Œã‚’ç”¨ã„ã‚‹ã€‚

```kotlin
@Composable
fun TransitionAnimatedVisibilitySample(modifier: Modifier = Modifier) {
    var selected by remember { mutableStateOf(false) }
    val transition = updateTransition(selected, label = "selected state")
    val borderColor by transition.animateColor(label = "border color") { isSelected ->
        if (isSelected) Color.Magenta else Color.White
    }
    val elevation by transition.animateDp(label = "elevation") { isSelected ->
        if (isSelected) 10.dp else 2.dp
    }
    Surface(
        onClick = { selected = !selected },
        shape = RoundedCornerShape(8.dp),
        border = BorderStroke(2.dp, borderColor),
        shadowElevation = elevation,
        modifier = modifier,
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp)
        ) {
            Text(text = "Hello, world!")
            transition.AnimatedVisibility(
                visible = { targetSelected -> targetSelected },
                enter = expandVertically(),
                exit = shrinkVertically()
            ) {
                Text(text = "It is fine today.")
            }
            transition.AnimatedContent { targetState ->
                if (targetState) {
                    Text(text = "Selected")
                } else {
                    Icon(imageVector = Icons.Default.Phone, contentDescription = "Phone")
                }
            }
        }
    }
}
```

![TransitionAnimatedVisibilitySample.gif](/images/b96dd78b67bf7a/TransitionAnimatedVisibilitySample.gif)

### ã‚«ãƒ—ã‚»ãƒ«åŒ–

UIã‚„ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãŒè¤‡é›‘ã«ãªã‚‹ã¨ã€Transitionã®çŠ¶æ…‹ã‚’ã‚«ãƒ—ã‚»ãƒ«åŒ–ã™ã‚‹ã“ã¨ãŒé‡è¦ã§ã™ã€‚

1. ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã®çŠ¶æ…‹ã‚’ã‚«ãƒ—ã‚»ãƒ«åŒ–ã™ã‚‹ãŸã‚ã®ãƒ›ãƒ«ãƒ€ãƒ¼(POKO)ã‚’ä½œã‚‹
2. Transitionã‚’ä½œæˆã—ã€1ã®ãƒ›ãƒ«ãƒ€ãƒ¼ã‚’è¿”ã™Composableé–¢æ•°ã‚’ä½œæˆã™ã‚‹
3. 2ã®Composableé–¢æ•°ã‚’ä½¿ã£ã¦ã€UIã‚’ä½œæˆã™ã‚‹

```kotlin
@Composable
fun AnimatingBox(modifier: Modifier = Modifier) {
    var boxState by remember { mutableStateOf(BoxState.Collapsed) }
    val transitionData = updateTransitionData(boxState)
    Box(
        modifier = modifier
            .size(transitionData.size)
            .background(transitionData.color)
            .clickable {
                boxState = when (boxState) {
                    BoxState.Collapsed -> BoxState.Expanded
                    BoxState.Expanded -> BoxState.Collapsed
                }
            }
    )
}

/**
 * ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã™ã‚‹å€¤ã‚’ã‚«ãƒ—ã‚»ãƒ«åŒ–ã—ãŸã‚¯ãƒ©ã‚¹
 */
private class TransitionData(
    color: State<Color>,
    size: State<Dp>,
) {
    val color by color
    val size by size
}

/**
 * updateTransitionã«å€£ã£ã¦ã€updateTransitionDataã¨ã„ã†åå‰ã«ã™ã‚‹
 * boxStateã®å¤‰æ›´ã«åŸºã¥ã„ã¦ã€transitionDataã®å€¤ã‚’æ›´æ–°ã™ã‚‹
 */
@Composable
private fun updateTransitionData(boxState: BoxState): TransitionData {
    val transition = updateTransition(boxState, label = "box state")
    val color = transition.animateColor(label = "color") { state ->
        when (state) {
            BoxState.Collapsed -> Color.Red
            BoxState.Expanded -> Color.Green
        }
    }
    val size = transition.animateDp(label = "size") { state ->
        when (state) {
            BoxState.Collapsed -> 64.dp
            BoxState.Expanded -> 128.dp
        }
    }
    return remember(transition) { TransitionData(color, size) }
}
```

![AnimatingBox.gif](/images/b96dd78b67bf7a/AnimatingBox.gif)

## rememberInfiniteTransition

ç„¡é™ã«ç¹°ã‚Šè¿”ã™ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ä½œæˆã™ã‚‹ãŸã‚ã®APIã§ã™ã€‚
InfiniteTransitionã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ `rememberInfiniteTransition` ã§ä½œæˆã—ã€ `animate*` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ç”¨ã—ã¦å€¤ã‚’ä½œæˆã—ã¾ã™ã€‚
ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§åˆ©ç”¨ã§ãã‚‹ãƒ¡ã‚½ãƒƒãƒ‰ã¯ä»¥ä¸‹ã®3ã¤ã§ã™ã€‚

- `animateColor`
- `animateFloat`
- `animateValue`

Dpã‚„Intãªã©ã®å‹ã¯ã€animateValueã‚’ä½¿ç”¨ã—ã¦ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³åŒ–ã§ãã¾ã™ã€‚ãã®éš›ã€typeConverterã‚’æŒ‡å®šã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚Dpã®å ´åˆã¯ã€Dp.VectorConverterã‚’æŒ‡å®šã—ã¾ã™ã€‚åŒæ§˜ã«ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã‚‹å‹ã«ã¤ã„ã¦ã¯VectorConverterãŒæä¾›ã•ã‚Œã¦ã„ã¾ã™ã€‚

ä¸Šè¨˜ã®ãƒ¡ã‚½ãƒƒãƒ‰ã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã¯ã“ã‚Œã¾ã§ã¨é•ã„ã€åˆæœŸå€¤ã¨ã‚¿ãƒ¼ã‚²ãƒƒãƒˆå€¤ã‚’ä¸¡æ–¹æŒ‡å®šã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

```kotlin
@Composable
fun InfiniteTransition.animateColor(
    initialValue: Color,
    targetValue: Color,
    animationSpec: InfiniteRepeatableSpec<Color>,
    label: String = "ColorAnimation"
)
```

ã¾ãŸã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã®æŒ™å‹•ã‚’æŒ‡å®šã™ã‚‹ãŸã‚ã«ã€InfiniteRepeatableSpecã‚’æ¸¡ã™å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚
InfiniteRepeatableSpecã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¯ `infiniteRepeatable` é–¢æ•°ã‚’ä½¿ç”¨ã—ã¦ä½œæˆã—ã¾ã™ã€‚
`infiniteRepeatable` ã¯animetionãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã«DurationBasedAnimationSpecã‚’å—ã‘å–ã‚Šã¾ã™ã€‚DurationBasedAnimationSpecã¯ã€`tween`ã€`keyframes`ã€`snap`ã®ã„ãšã‚Œã‹ã‚’æŒ‡å®šã§ãã¾ã™ã€‚(springã¯æŒ‡å®šã§ãã¾ã›ã‚“ã€‚)

```kotlin
@Stable
fun <T> infiniteRepeatable(
    animation: DurationBasedAnimationSpec<T>,
    repeatMode: RepeatMode = RepeatMode.Restart,
    initialStartOffset: StartOffset = StartOffset(0)
)
```

```kotlin
@Composable
fun InfiniteTransitionSample(modifier: Modifier = Modifier) {
    val transition = rememberInfiniteTransition(label = "infinite transition")
    val color by transition.animateColor(
        initialValue = Color.Red,
        targetValue = Color(0xffffc56e),
        animationSpec = infiniteRepeatable(
            animation = tween(2000),
            repeatMode = RepeatMode.Reverse,
        ),
        label = "color",
    )
    val size by transition.animateValue(
        initialValue = 100.dp,
        targetValue = 120.dp,
        typeConverter = Dp.VectorConverter,
        animationSpec = infiniteRepeatable(
            animation = tween(2000),
            repeatMode = RepeatMode.Reverse,
        ),
        label = "size",
    )
    Box(
        contentAlignment = Alignment.Center,
        modifier = modifier
            .size(200.dp)
    ) {
        Box(
            modifier = Modifier
                .clip(CircleShape)
                .size(size)
                .background(color)
        )
    }
}
```

![InfiniteTransitionSample.gif](/images/b96dd78b67bf7a/InfiniteTransitionSample.gif)

## å‚è€ƒè³‡æ–™
https://developer.android.com/jetpack/compose/animation/value-based?hl=en
https://github.com/mikanIchinose/android-compose-animation-sample